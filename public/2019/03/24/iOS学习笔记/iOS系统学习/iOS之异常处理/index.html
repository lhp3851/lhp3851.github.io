<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Hexo
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>HEXO</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  
</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <p>1、异常日志收集</p>
<ul>
<li>   Xcode、App Store</li>
<li>  第三方 </li>
<li>自己收集<pre><code>  跟踪异常产生的时机并捕捉、处理：上报之类
  [iOS Swift Crash的捕获](http://www.cocoachina.com/ios/20170816/20270.html)
  [漫谈iOS Crash收集框架](https://nianxi.net/ios/ios-crash-reporter.html)
  [dSYMTools](https://blog.csdn.net/wiseuc_jianghai/article/details/78031638)
  [DWARF 介绍](https://www.jianshu.com/p/20dfe4fe1b3f)[DWARF 介绍](https://www.jianshu.com/p/20dfe4fe1b3f)
  
</code></pre>
2、异常日志分析</li>
</ul>
<p>一、.dSYM</p>
<p>.dSYM(debugging SYMbols)又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的DWARF（Debugging With Attributed Record Formats），其在.xcarchive目录中的层次结构为：</p>
<pre><code>.xcarchive
--dSYMs
  |--Your.app.dSYM
    |--Contents
      |--Resources
        |--DWARF
        
</code></pre>
<p>二、确定符号表和崩溃日志的一致性</p>
<p>有了符号表文件，有了崩溃日志文件，在解析之前一定要确保二者的对应关系，否则就算按照下述步骤解析出内容也肯定是不准确的。二者的对应关系可以通过UUID来确定。</p>
<p>1、从崩溃日志中获取UUID</p>
<p>崩溃日志比较靠下的位置有个Binary Images模块，其第一行内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x1f000 - 0x906fff sd_doctor_ios armv7  &lt;eef4e325f9d6393f93e87b7ee327a5ea&gt; &#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;8BEEC659-8263-4092-A2DC-EF48060BB142&#x2F;sd_doctor_ios.app&#x2F;sd_doctor_ios</span><br></pre></td></tr></table></figure>

<p>从中可以看到关于你应用的若干信息：</p>
<p>代码段的起终地址为：0x1f000 - 0x906fff</p>
<p>运行你应用的CPU指令集为：armv7</p>
<p>应用的UUID为：687D78E2-36CC-35C3-BD39-7D5B21E281B5（不区分大小写）</p>
<p>2、从符号表中获取UUID</p>
<p>执行以下命令从符号表中提取UUID：</p>
<pre><code>dwarfdump --uuid Your.app.dSYM
dwarfdump --uuid Your.app.dSYM/Contents/Resources/DWARF/Your
</code></pre>
<p>由此得到armv7指令集的UUID为：687D78E2-36CC-35C3-BD39-7D5B21E281B5（如果你的二进制文件支持多个指令集，这里会列出每个指令集对应符号表的UUID），通过和崩溃日志中的对比发现二者一致，才可进行进一步的解析操作。</p>
<p>三、计算崩溃符号表地址<br>以下面的崩溃堆栈为例：</p>
<pre><code>Thread 0:
0   libobjc.A.dylib                   0x33f10f60 0x33efe000 + 77664
1   Foundation                        0x273526ac 0x2734a000 + 34476
2   Foundation                        0x27355c3e 0x2734a000 + 48190
3   UIKit                             0x29ef9d1c 0x29bbc000 + 3398940
4   UIKit                             0x29ef9c9a 0x29bbc000 + 3398810
5   UIKit                             0x29ef954c 0x29bbc000 + 3396940
6   UIKit                             0x29c3a16a 0x29bbc000 + 516458
7   UIKit                             0x29e4b8e6 0x29bbc000 + 2685158
8   UIKit                             0x29c3a128 0x29bbc000 + 516392
9   Your                              0x000f0846 0xa2000 + 321606
10  UIKit                             0x29e90fb2 0x29bbc000 + 2969522
11  UIKit                             0x29e91076 0x29bbc000 + 2969718
12  UIKit                             0x29e867cc 0x29bbc000 + 2926540
13  UIKit                             0x29c9e8ea 0x29bbc000 + 927978
14  UIKit                             0x29bc8a6a 0x29bbc000 + 51818
15  QuartzCore                        0x295f0a08 0x295e4000 + 51720
16  QuartzCore                        0x295ec3e0 0x295e4000 + 33760
17  QuartzCore                        0x295ec268 0x295e4000 + 33384
18  QuartzCore                        0x295ebc4c 0x295e4000 + 31820
19  QuartzCore                        0x295eba50 0x295e4000 + 31312
20  QuartzCore                        0x295e5928 0x295e4000 + 6440
21  CoreFoundation                    0x266d0d92 0x26604000 + 839058
22  CoreFoundation                    0x266ce44e 0x26604000 + 828494
23  CoreFoundation                    0x266ce856 0x26604000 + 829526
24  CoreFoundation                    0x2661c3bc 0x26604000 + 99260
25  CoreFoundation                    0x2661c1ce 0x26604000 + 98766
26  GraphicsServices                  0x2da1a0a4 0x2da11000 + 37028
27  UIKit                             0x29c2a7ac 0x29bbc000 + 452524
28  Your                              0x0024643a 0xa2000 + 1721402
29  libdyld.dylib                     0x34484aac 0x34483000 + 6828
</code></pre>
<p>1、 符号表堆栈地址计算方式</p>
<p>要想利用符号表解析出崩溃对应位置，需要计算出符号表中对应的崩溃堆栈地址。而从上述堆栈中第9行可以看到，应用崩溃发生在运行时地址0x000f0846，该进程的运行时起始地址是0xa2000，崩溃处距离进程起始地址的偏移量为十进制的321606(对应十六进制为0x4E846)。三者对应关系：</p>
<pre><code>0x000f0846 = 0xa2000 + 0x4E846
</code></pre>
<p>对应的公式为：</p>
<pre><code>运行时堆栈地址 = 运行时起始地址 + 偏移量
</code></pre>
<p>崩溃堆栈中的起始地址和崩溃地址均为运行时地址，根据虚拟内存偏移量不变原理，只要提供了符号表TEXT段的起始地址，再加上偏移量（这里为0x4E846）就能得到符号表中的堆栈地址，即：</p>
<pre><code>符号表堆栈地址 = 符号表起始地址 + 偏移量
</code></pre>
<p>2、获取符号表中的TEXT段起始地址</p>
<p>符号表中TEXT段的起始地址可以通过以下命令获得：</p>
<pre><code>$otool -l Your.app.dSYM/Contents/Resources/DWARF/Your
</code></pre>
<p>运行结果中的片段如下：</p>
<pre><code>Load command 3
      cmd LC_SEGMENT
  cmdsize 736
  segname __TEXT
   vmaddr 0x00004000
   vmsize 0x00700000
  fileoff 0
 filesize 0
  maxprot 0x00000005
 initprot 0x00000005
   nsects 10
    flags 0x0
    
</code></pre>
<p>其中的vmaddr 0x00004000字段即为TEXT段的起始地址。</p>
<p>3、计算符号表地址</p>
<p>由公式：</p>
<pre><code>符号表堆栈地址 = 符号表起始地址 + 偏移量
</code></pre>
<p>可得：</p>
<pre><code>0x52846 = 0x4E846 + 0x4000
</code></pre>
<p>即符号表中的崩溃地址为0x52846，接下来就可以根据这个地址解析出崩溃位置了。</p>
<p>四、崩溃信息还原</p>
<p>有了符号表的崩溃地址，有以下几种方式解析崩溃信息：</p>
<p>1、dwarfdump</p>
<p>命令如下：</p>
<pre><code>$dwarfdump --arch armv7 Your.app.dSYM --lookup 0x52846 | grep &#39;Line table&#39;
</code></pre>
<p>需要注意的是：    </p>
<pre><code>这里的armv7是运行设备的CPU指令集，而不是二进制文件的指令集
</code></pre>
<p>比如armv7指令集的二进制文件运行在arm64指令集的设备上，这个地方应该写arm64。</p>
<p>—lookup后面跟的一定是经过准确计算的符号表中的崩溃地址</p>
<p>使用dwarfdump解析的结果较杂乱，因此使用grep命令抓取其中关键点展示出来</p>
<p>运行结果如下：</p>
<pre><code>Line table dir : &#39;/data/.../Src/OBDConnectSetting/Controller&#39;
Line table file: &#39;OBDFirstConnectViewController.m&#39; line 882, column 5 with start address 0x000000000052768
</code></pre>
<p>其中第一行是编译时文件目录，第二行包含了崩溃发生的文件名称以及文件中具体行号等信息，有了这些信息就能准确定位崩溃原因啦。</p>
<p>2、atos</p>
<p>atos是另一种更加简洁的崩溃日志解析方法，使用方式如下：</p>
<pre><code> $atos -o LuBao -arch armv7 0x52846
</code></pre>
<p>其执行结果如下：</p>
<pre><code>-[OBDFirstConnectViewController showOilPricePickerView] (in Your) (OBDFirstConnectViewController.m:882)
</code></pre>
<p>相对dwarfdump命令的解析结果，更加简洁直观的指出了崩溃发生的位置。</p>
<p>3、无需符号表崩溃地址的解析方式</p>
<p>实际上，atos还提供了另外一种无需计算崩溃地址对应的符号表地址的方式，命令格式如下：</p>
<pre><code>$atos -o Your.app.dSYM/Contents/Resources/DWARF/Your -arch armv7 -l 0xa2000 0x000f0846
</code></pre>
<p>其中-l选项指定了二进制文件在运行时的起始地址0xa2000（获取方式见Binary Images相关内容）,后面跟的是崩溃发生的运行时地址0x000f0846，解析结果和使用计算得到的符号表中崩溃地址一致：</p>
<pre><code>-[OBDFirstConnectViewController showOilPricePickerView] (in Your) (OBDFirstConnectViewController.m:882)
</code></pre>
<p>五、参考文档</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/qa/qa1765/_index.html">How to Match a Crash Report to a Build</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/technotes/tn2004/tn2123.html">CrashReporter</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/technotes/tn2151/_index.html">Understanding and Analyzing iOS Application Crash Reports</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://stackoverflow.com/a/12464678/2293677">atos and dwarfdump won’t symbolicate my address</a></p>
</li>
</ul>
<p><strong>原文参考：</strong><a target="_blank" rel="noopener" href="http://www.cocoachina.com/ios/20150803/12806.html">手动解析CrashLog</a></p>
<p>3、异常处理<br>4、异常规避</p>
<ul>
<li>内存地址分配</li>
<li>日志源文件</li>
<li>异常产生</li>
</ul>
<p>Linux系统中，支持两类信号</p>
<p>1.POSIX标准的规则信号(regular signal，编号1－31)</p>
<p>2.实时信号(real-time signal，编号32－63)</p>
<p>对于regular signal来说，无论发送多少次，在接收进程处理之前，重复的信号会被合并为一个（每一种regular signal对应于系统进程表项中软中断字段的一个比特，因此不同的信号可以同时存在，同一信号仅能表示有或无而不能表示重复的次数)；</p>
<p>而real-time signal发送多少次，就会在接收进程的信号队列中出现多少次。<br>Linux在i386上的31个规则信号(regular signal)</p>
<pre><code>kill -l
</code></pre>
<table>
<thead>
<tr>
<th>编号</th>
<th>信号名称</th>
<th>缺省动作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止</td>
<td>终止控制终端或进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>键盘产生的中断(Ctrl-C)</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>dump</td>
<td>键盘产生的退出</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>dump</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>dump</td>
<td>debug中断</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT／SIGIOT</td>
<td>dump</td>
<td>异常中止</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS／SIGEMT</td>
<td>dump</td>
<td>总线异常/EMT指令</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>dump</td>
<td>浮点运算溢出</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止</td>
<td>强制进程终止</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>终止</td>
<td>用户信号,进程可自定义用途</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>dump</td>
<td>非法内存地址引用</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>终止</td>
<td>用户信号，进程可自定义用途</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止</td>
<td>向某个没有读取的管道中写入数据</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止</td>
<td>时钟中断(闹钟)</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止</td>
<td>进程终止</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>终止</td>
<td>协处理器栈错误</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略</td>
<td>子进程退出或中断</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>继续</td>
<td>如进程停止状态则开始运行</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止</td>
<td>停止进程运行</td>
</tr>
<tr>
<td>20</td>
<td>SIGSTP</td>
<td>停止</td>
<td>键盘产生的停止</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止</td>
<td>后台进程请求输入</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>停止</td>
<td>后台进程请求输出</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>忽略</td>
<td>socket发生紧急情况</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>dump</td>
<td>CPU时间限制被打破</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>dump</td>
<td>文件大小限制被打破</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>终止</td>
<td>虚拟定时时钟</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止</td>
<td>profile timer clock</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>忽略</td>
<td>窗口尺寸调整</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO/SIGPOLL</td>
<td>终止</td>
<td>I/O可用</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>终止</td>
<td>电源异常</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS／SYSUNUSED</td>
<td>dump</td>
<td>系统调用异常</td>
</tr>
</tbody></table>
<p>在不同系统中同一数值可能会代表不同的信号，因此，最好使用信号名而不是信号值。</p>
<p>信号的数值越小，则优先级越高。当进程收到多个待处理信号时，总是先处理优先级别高的信号。</p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="J"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>John Doe</div>
      <div>2019-03-24</div>
    </div>
  </div>

  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
