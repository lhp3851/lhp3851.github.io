---
title: iOS之持久化
abbrlink: 396dcc83
date: 2021-04-20 21:36:02
tags:
---
## 1. 数据库

### 1.1 [SQLite](https://www.sqlite.org/docs.html)

#### 1.1.1 [w3cschool SQLite](https://www.w3cschool.cn/sqlite/sqlite-tutorial.html)

#### 1.1.2 [SQLite 事务](https://www.sunzn.com/2017/11/24/SQLite-%E4%BA%8B%E5%8A%A1/)

##### 1.1.2.1 冲突解决

* SQLite 提供 5 种可能的冲突解决方案或策略，它们可以用来解决冲突（约束违反）：replace、ignore、fail、abort 和 rollback。这 5 种方法定义了错误容忍范围或敏感度：从最宽松的 replace，到最严格的 rollback。这些解决方法的定义如下（按严重度排序）：

* replace：当违反了唯一性约束时，SQLite 将造成这种违反的记录删除，以插入或修改的新记录替代，SQL 继续执行，且不报错。如果违反了 NOT NULL 约束，使用该字段的默认值替代 NULL。如果该字段没有默认值，SQLite 应用 abort 策略。有一点要特别注意，当冲突解决策略为了满足约束而删除记录时，该行的删除触发器不会被触发。这种行为可能在将来的版本中改变。

* ignore：当约束违反发生时，SQLite 允许命令继续执行，违反约束的行保持不变。而它之前和之后的记录都继续修改。也就是说，所有会触发约束违反的行都不动，保持原貌，命令继续处理其他的，且不报错。

* fail：当约束违反发生时，SQLite 终止命令，但是不恢复约束违反之前已经修改的记录。也就是说，在约束违反发生前的改变都保留。例如，如果 UPDATE 命令在第 100 行违反约束，那么前 99 行已经修改的记录不会回滚。但是对第 100 行和之外的改变不会发生，因为命令已经终止了。

* abort：当约束违反发生时，SQLite 恢复命令所做的所有改变并终止命令。abort 是 SQLite 中所有操作的默认解决方法，也是 SQL 标准定义的行为。注意：abort 也是最昂贵的冲突解决策略——要求额外的工作，设置要求没有冲突发生。

* rollback：当约束违反发生时，SQLite 执行回滚——终止当前命令和整个事务。最终结果就是当前命令所做的改变和事务中之前命令的改变都被回滚。这也是最严格的冲突解决方法，单个约束违反导致事务中执行的所有操作都回滚。

##### 1.1.2.2 数据库锁

在 SQLite 中，锁和事务是紧密联系的。要有效地使用事务，需要了解一些关于如何加锁的知识。SQLiite 采用粗粒度的锁。当一个连接要写数据库时，所有其他的连接被锁住，直到写连接结束它的事务。SQLite 有一个加锁表，用来帮助不同的写数据库都能在最后一刻再加锁，以保证最大的并发性。

SQLite 使用锁逐步提升机制，为了写数据库，连接需要逐级获得排它锁。SQLiite 有 5 种不同的锁状态：`未加锁（unlocked）、共享（shared）、预留（reserved）、未决（pending）和排它（exclusive）`。每个数据库连接在同一时刻只能处于其中一个状态，每个状态（未加锁状态除外）都有一种锁与之对应。

最初的状态是`未加锁`状态，在此状态下，连接还没有访问数据库。当连接一个数据库，甚至已经用 BEGIN 开始了一个事务时，连接都还处于未加锁状态。

`未加锁`的下一个状态是`共享状态`。为了能够从数据库种读（不是写）数据，连接必须首先进入共享状态，也就是说，首先要获得一个`共享锁`。多个连接可以同时获得并保持共享锁，也就是说，多个连接可以同时从同一个数据库中读数据。但哪怕只有一个共享锁还没有释放，也不允许任何连接写数据库。

如果一个连接想要写数据库，它必须首先获得一个`预留锁`。一个数据库同时只能有一个`预留锁`，该`预留锁`可以与`共享锁`共存，它是写数据库的第一阶段。`预留锁`既不阻止其他拥有`共享锁`的连接继续读取数据库，也不阻止其他连接获得新的`共享锁`。

一旦一个连接获得了`预留锁`，它就可以开始处理数据库修改操作了，尽管这些修改只能在缓冲区中进行，而不是实际写到磁盘，对读出内容所做的修改保存在内存缓冲区中。

当连接想要提交修改（事务）时，需要将`预留锁`提升为`排它锁`。为了得到`排它锁`，还必须首先将`预留锁`提升为`未决锁`。获得`未决锁`之后，其他连接就不能再获得新的`共享锁`了，但已经拥有`共享锁`的连接仍然可以继续正常读数据库。此时，拥有`未决锁`的连接等待其他拥有`共享锁`的连接完成工作并释放其`共享锁`。

一旦所有的其他共享锁都被释放，拥有`未决锁`的连接就可以将其锁提升至`排它锁`，此时就可以自由地对数据库进行修改。所有以前缓存的修改都会被写到数据库文件中。

##### 1.1.2.3 死锁防御

##### 1.1.2.4 事务类型：deferred、immediate 或 exclusive

* 一个 deferred 直到必须使用时才获取锁。因此，对于延迟事务，begin 语句本身不会做什么事情——它从未锁定状态开始。这是默认的情况。如果仅仅用 begin 开始一个事务，那么事务就是延迟的，停留在未锁定状态。多个连接可以在同一时刻未创建任何锁的情况下开始延迟事务。这种情况下，第一个对数据库的读操作获取共享锁，类似地，第一个对数据库的写操作试图获取预留锁。

* 由 begin 开始的 immediate 事务在 begin 执行时试图获取预留锁。如果成功，begin immediate 保证没有其他的连接可以写数据库。正如你知道的，其他的连接可以继续对数据库进行读操作，但是，预留锁会阻止其他新的读取数据库。预留锁的另一个结果是没有其他连接能成功启动 begin immediate 或者 begin exclusive 命令，当其他连接执行上述命令时，SQLite 会返回 SQLITE_BUSY 错误。这时你可以对数据库进行修改操作，但是你还不能提交，当调用 commit 时，会返回 SQLITE_BUSY 错误。这意味着还有其他的读事务没有完成，需要等它们执行完后才能提交事务。

* exclusive 事务会试着获取对数据库的排它锁。这与 immediate 的工作方式类似，但是一旦成功，exclusive 事务保证数据库中没有其他的活动连接，所以就可对数据库进行任意的读写操所。

* 基本的准则是：如果使用的数据库没有其他连接，用 begin 就足够了。但是，如果使用的数据库有其他也会对数据库进行写操作的连接，就得使用 begin immediate 或 begin exclusive 开启事务。

## 1.2 [Core data](https://developer.aliyun.com/article/117778)

### 1.3 [FFMDB](https://github.com/ccgus/fmdb)

#### 1.3.1 [sqlite之WAL模式](https://www.cnblogs.com/huahuahu/p/sqlite-zhiWAL-mo-shi.html)

WAL模式原理

回滚日志的方法是把为改变的数据库文件内容写入日志里，然后把改变后的内容直接写到数据库文件中去。在系统crash或掉电的情况下，日志里的内容被重新写入数据库文件中。日志文件被删除，标志commit着一次commit的结束。

WAL模式于此此相反。原始为改变的数据库内容在数据库文件中，对数据库文件的修改被追加到单独的WAL文件中。当一条记录被追加到WAL文件后，标志着一次commit的结束。因此一次commit不必对数据库文件进行操作，当正在进行写操作时，可以同时进行读操作。多个事务的内容可以追加到一个WAL文件的末尾。

##### 1.3.1.1 `checkpoint`

最后WAL文件的内容必须更新到数据库文件中。把WAL文件的内容更新到数据库文件的过程叫做一次checkpoint。
回滚日志的方法有两种操作：读和写。WAL有三种操作，读、写和`checkpoint`。
默认的，SQL会在WAL文件达到1000page时进行一次 `checkpoint`。进行WAL的时机也可以由应用程序自己决定。

##### 1.3.1.2 并发性

当一个读操作发生在WAL模式的数据库上时，会首先找到WAL文件中最后一次提交，叫做`"end mark"`。每一个事务可以有自己的`"end point"`，但对于一个给定额事务来说，`end mark`是固定的。
当读取数据库中的`page`时，SQLite会先从WAL文件中寻找有没有对应的`page`，从找出离`end mark`最近的那一条记录；如果找不到，那么就从数据库文件中寻找对一个的`page`。为了避免每次事务都要扫描一遍WAL文件，SQLite在共享内存中维护了一个`"wal-index"`的数据结构，帮助快速定位`page`。
写数据库只是把新内容加到WAL文件的末尾，和读操作没有关系。由于只有一个WAL文件，因此同时只能有一个写操作。
`checkpoint`操作可以和读操作并行。但是如果`checkpoint`把一个`page`写入数据库文件，而且这个`page`超过了当前读操作的`end mark`时，`checkpoint`必须停止。否则会把当前正在读的部分覆盖掉。下次`checkpoint`时，会从这个`page`开始往数据库中拷贝数据。
当写操作时，会检查WAL文件被拷贝到数据库的进度。如果已经完全被拷贝到数据库文件中，已经同步，并且没有读操作在使用WAL文件，那么会把WAL文件清空，从其实开始追加数据。保证WAL文件不会无限制增长。

##### 1.3.1.3. 性能

写操作是很快的，因为只需要进行一次写操作，并且是顺序的（不是随机的，每次都写到末尾）。而且，把数据刷到磁盘上是不必须的。（如果`PRAGMA synchronous`是FULL，每次commit要刷一次，否则不刷。）
读操作的性能有所下降，因为需要从WAL文件中查找内容，花费的时间和WAL文件的大小有关。`wal-index`可以缩短这个时间，但是也不能完全避免。因此需要保证WAL文件的不会太大。
为了保护数据库不被损坏，需要在把WAL文件写入数据库之前把WAL文件刷入磁盘；在重置WAL文件之前要把数据库内容刷入数据库文件。此外`checkpoint`需要查找操作。这些因素使得`checkpoint`比写操作慢一些。
默认策略是很多线程可以增长WAL文件。把WAL文件大小变得比1000page大的那个线程要负责进行`checkpoint`。会导致绝大部分读写操作都是很快的，随机有一个写操作非常慢。也可以禁用自动`checkpoint`的策略，定期在一个线程或进程中进行`checkpoint`操作。
高效的写操作希望WAL文件越大越好；高效的读操作希望WAL文件越小越好。两者存在一个`tradeoff`。

## 2. 文件

### 2.1 [浅谈Linux虚拟文件系统](https://zhuanlan.zhihu.com/p/69289429)

## 3. plist

## 4. 归档

## 5. keychain

## 6. Userdefault

### 6.1 [MMKV](https://github.com/Tencent/MMKV/blob/master/README_CN.md)
