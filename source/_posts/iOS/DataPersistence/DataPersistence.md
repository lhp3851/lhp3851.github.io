---
title: iOS之持久化
abbrlink: 396dcc83
date: 2021-04-20 21:36:02
tags:
---
## 1. 数据库

### 1.1 [SQLite](https://www.sqlite.org/docs.html)

#### 1.1.1 [w3cschool SQLite](https://www.w3cschool.cn/sqlite/sqlite-tutorial.html)

#### 1.1.2 [SQLite 事务](https://www.sunzn.com/2017/11/24/SQLite-%E4%BA%8B%E5%8A%A1/)

##### 1.1.2.1 冲突解决

* SQLite 提供 5 种可能的冲突解决方案或策略，它们可以用来解决冲突（约束违反）：replace、ignore、fail、abort 和 rollback。这 5 种方法定义了错误容忍范围或敏感度：从最宽松的 replace，到最严格的 rollback。这些解决方法的定义如下（按严重度排序）：

* replace：当违反了唯一性约束时，SQLite 将造成这种违反的记录删除，以插入或修改的新记录替代，SQL 继续执行，且不报错。如果违反了 NOT NULL 约束，使用该字段的默认值替代 NULL。如果该字段没有默认值，SQLite 应用 abort 策略。有一点要特别注意，当冲突解决策略为了满足约束而删除记录时，该行的删除触发器不会被触发。这种行为可能在将来的版本中改变。

* ignore：当约束违反发生时，SQLite 允许命令继续执行，违反约束的行保持不变。而它之前和之后的记录都继续修改。也就是说，所有会触发约束违反的行都不动，保持原貌，命令继续处理其他的，且不报错。

* fail：当约束违反发生时，SQLite 终止命令，但是不恢复约束违反之前已经修改的记录。也就是说，在约束违反发生前的改变都保留。例如，如果 UPDATE 命令在第 100 行违反约束，那么前 99 行已经修改的记录不会回滚。但是对第 100 行和之外的改变不会发生，因为命令已经终止了。

* abort：当约束违反发生时，SQLite 恢复命令所做的所有改变并终止命令。abort 是 SQLite 中所有操作的默认解决方法，也是 SQL 标准定义的行为。注意：abort 也是最昂贵的冲突解决策略——要求额外的工作，设置要求没有冲突发生。

* rollback：当约束违反发生时，SQLite 执行回滚——终止当前命令和整个事务。最终结果就是当前命令所做的改变和事务中之前命令的改变都被回滚。这也是最严格的冲突解决方法，单个约束违反导致事务中执行的所有操作都回滚。

##### 1.1.2.2 数据库锁

在 SQLite 中，锁和事务是紧密联系的。要有效地使用事务，需要了解一些关于如何加锁的知识。SQLiite 采用粗粒度的锁。当一个连接要写数据库时，所有其他的连接被锁住，直到写连接结束它的事务。SQLite 有一个加锁表，用来帮助不同的写数据库都能在最后一刻再加锁，以保证最大的并发性。

SQLite 使用锁逐步提升机制，为了写数据库，连接需要逐级获得排它锁。SQLiite 有 5 种不同的锁状态：`未加锁（unlocked）、共享（shared）、预留（reserved）、未决（pending）和排它（exclusive）`。每个数据库连接在同一时刻只能处于其中一个状态，每个状态（未加锁状态除外）都有一种锁与之对应。

最初的状态是`未加锁`状态，在此状态下，连接还没有访问数据库。当连接一个数据库，甚至已经用 BEGIN 开始了一个事务时，连接都还处于未加锁状态。

`未加锁`的下一个状态是`共享状态`。为了能够从数据库种读（不是写）数据，连接必须首先进入共享状态，也就是说，首先要获得一个`共享锁`。多个连接可以同时获得并保持共享锁，也就是说，多个连接可以同时从同一个数据库中读数据。但哪怕只有一个共享锁还没有释放，也不允许任何连接写数据库。

如果一个连接想要写数据库，它必须首先获得一个`预留锁`。一个数据库同时只能有一个`预留锁`，该`预留锁`可以与`共享锁`共存，它是写数据库的第一阶段。`预留锁`既不阻止其他拥有`共享锁`的连接继续读取数据库，也不阻止其他连接获得新的`共享锁`。

一旦一个连接获得了`预留锁`，它就可以开始处理数据库修改操作了，尽管这些修改只能在缓冲区中进行，而不是实际写到磁盘，对读出内容所做的修改保存在内存缓冲区中。

当连接想要提交修改（事务）时，需要将`预留锁`提升为`排它锁`。为了得到`排它锁`，还必须首先将`预留锁`提升为`未决锁`。获得`未决锁`之后，其他连接就不能再获得新的`共享锁`了，但已经拥有`共享锁`的连接仍然可以继续正常读数据库。此时，拥有`未决锁`的连接等待其他拥有`共享锁`的连接完成工作并释放其`共享锁`。

一旦所有的其他共享锁都被释放，拥有`未决锁`的连接就可以将其锁提升至`排它锁`，此时就可以自由地对数据库进行修改。所有以前缓存的修改都会被写到数据库文件中。

##### 1.1.2.3 死锁防御

##### 1.1.2.4 事务类型：deferred、immediate 或 exclusive

* 一个 deferred 直到必须使用时才获取锁。因此，对于延迟事务，begin 语句本身不会做什么事情——它从未锁定状态开始。这是默认的情况。如果仅仅用 begin 开始一个事务，那么事务就是延迟的，停留在未锁定状态。多个连接可以在同一时刻未创建任何锁的情况下开始延迟事务。这种情况下，第一个对数据库的读操作获取共享锁，类似地，第一个对数据库的写操作试图获取预留锁。

* 由 begin 开始的 immediate 事务在 begin 执行时试图获取预留锁。如果成功，begin immediate 保证没有其他的连接可以写数据库。正如你知道的，其他的连接可以继续对数据库进行读操作，但是，预留锁会阻止其他新的读取数据库。预留锁的另一个结果是没有其他连接能成功启动 begin immediate 或者 begin exclusive 命令，当其他连接执行上述命令时，SQLite 会返回 SQLITE_BUSY 错误。这时你可以对数据库进行修改操作，但是你还不能提交，当调用 commit 时，会返回 SQLITE_BUSY 错误。这意味着还有其他的读事务没有完成，需要等它们执行完后才能提交事务。

* exclusive 事务会试着获取对数据库的排它锁。这与 immediate 的工作方式类似，但是一旦成功，exclusive 事务保证数据库中没有其他的活动连接，所以就可对数据库进行任意的读写操所。

* 基本的准则是：如果使用的数据库没有其他连接，用 begin 就足够了。但是，如果使用的数据库有其他也会对数据库进行写操作的连接，就得使用 begin immediate 或 begin exclusive 开启事务。

## 1.2 [Core data](https://developer.aliyun.com/article/117778)

### 1.3 [FFMDB](https://github.com/ccgus/fmdb)

## 2. 文件

## 3. plist

## 4. 归档

## 5. keychain

## 6. Userdefault

### 6.1 [MMKV](https://github.com/Tencent/MMKV/blob/master/README_CN.md)
