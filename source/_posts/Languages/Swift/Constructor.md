---
title: iOS编程语言之swift 构造器
abbrlink: bde5b828
date: 2021-04-20 21:36:02
tags:
---
## swift 构造器

1、默认初始化器
Swift 为所有没有提供初始化器的结构体或类提供了一个默认的初始化器来给所有的属性提供了默认值。
这个默认的初始化器只是简单地创建了一个所有属性都有默认值的新实例

2、结构体类型的成员初始化器
如果结构体类型中没有定义任何自定义初始化器，它会自动获得一个成员初始化器。
不同于默认初始化器，结构体会接收成员初始化器即使它的存储属性没有默认值。

3、值类型的初始化器委托
初始化器可以调用其他初始化器来执行部分实例的初始化。这个过程，就是所谓的初始化器委托，避免了多个初始化器里冗余代码。

初始化器委托的运作，以及允许那些形式的委托，这些规则对于值类型和类类型是不同的。值类型(结构体和枚举)不支持继承，
所以他它们的初始化器委托的过程相当简单，因为它们只能提供它们自己为另一个初始化器委托。如同继承里描述的那样，
总之，类可以从其他类继承。这就意味着类有额外的责任来确保它们继承的所有存储属性在初始化期间都分配了一个合适的值。
这些责任在下边的类的继承和初始化里做详述。

4、类的继承和初始化
所有类的存储属性——包括从它的父类继承的所有属性——都必须在初始化期间分配初始值。

Swift 为类类型定义了两种初始化器以确保所有的存储属性接收一个初始值。这些就是所谓的指定初始化器和便捷初始化器。
*指定初始化器

*便利构造器
   convenience:便利，使用convenience修饰的构造函数叫做便利构造函数
   便利构造函数通常用在对系统的类进行构造函数的扩充时使用。
   便利构造函数的特点：
   1、便利构造函数通常都是写在extension里面
   2、便利函数init前面需要加载convenience
   3、在便利构造函数中需要明确的调用self.init()

4.1、类类型的初始化器委托
为了简化指定和便捷初始化器之间的调用关系，Swift 在初始化器之间的委托调用有下面的三个规则:

规则 1
指定初始化器必须从它的直系父类调用指定初始化器。

规则 2
便捷初始化器必须从相同的类里调用另一个初始化器。

规则 3
便捷初始化器最终必须调用一个指定初始化器。

4.2、两段式初始化
Swift 的类初始化是一个两段式过程。在第一个阶段，每一个存储属性被引入类为分配了一个初始值。
一旦每个存储属性的初始状态被确定，第二个阶段就开始了，每个类都有机会在新的实例准备使用之前来定制它的存储属性。

Swift编译器执行四种有效的安全检查来确保两段式初始化过程能够顺利完成：

安全检查 1
指定初始化器必须保证在向上委托给父类初始化器之前，其所在类引入的所有属性都要初始化完成。

如上所述，一个对象的内存只有在其所有储存型属性确定之后才能完全初始化。为了满足这一规则，指定初始化器必须保证它自己的属性在它上交委托之前先完成初始化。

安全检查 2
指定初始化器必须先向上委托父类初始化器，然后才能为继承的属性设置新值。如果不这样做，指定初始化器赋予的新值将被父类中的初始化器所覆盖。

安全检查 3
便捷初始化器必须先委托同类中的其它初始化器，然后再为任意属性赋新值（包括同类里定义的属性）。如果没这么做，
便捷构初始化器赋予的新值将被自己类中其它指定初始化器所覆盖。

安全检查 4
初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用 self 作为值。

直到第一阶段结束类实例才完全合法。属性只能被读取，方法也只能被调用，直到第一阶段结束的时候，这个类实例才被看做是合法的。

以下是两段初始化过程，基于上述四种检查的流程：

4.3、两端初始化总结：
阶段 1
指定或便捷初始化器在类中被调用；
为这个类的新实例分配内存。内存还没有被初始化；
这个类的指定初始化器确保所有由此类引入的存储属性都有一个值。现在这些存储属性的内存被初始化了；
指定初始化器上交父类的初始化器为其存储属性执行相同的任务；
这个调用父类初始化器的过程将沿着初始化器链一直向上进行，直到到达初始化器链的最顶部；
一旦达了初始化器链的最顶部，在链顶部的类确保所有的存储属性都有一个值，此实例的内存被认为完全初始化了，此时第一阶段完成。

阶段 2
从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例。初始化器现在能够访问 self 并且可以修改它的属性，调用它的实例方法等等；
最终，链中任何便捷初始化器都有机会定制实例以及使用 slef 。

5、初始化器的继承和重写

不像在 Objective-C 中的子类，Swift 的子类不会默认继承父类的初始化器。
Swift 的这种机制防止父类的简单初始化器被一个更专用的子类继承并被用来创建一个没有完全或错误初始化的新实例的情况发生。

初始化器的自动继承
如上所述，子类默认不会继承父类初始化器。总之，在特定的情况下父类初始化器是可以被自动继承的。实际上，这意味着在许多场景中你不必重写父类初始化器，只要可以安全操作，你就可以毫不费力地继承父类的初始化器。

假设你为你子类引入的任何新的属性都提供了默认值，请遵守以下2个规则：

规则1
如果你的子类没有定义任何指定初始化器，它会自动继承父类所有的指定初始化器。

规则2
如果你的子类提供了所有父类指定初始化器的实现——要么是通过规则1继承来的，要么通过在定义中提供自定义实现的——那么它自动继承所有的父类便捷初始化器。

就算你的子类添加了更多的便捷初始化器，这些规则仍然适用。

*注意
子类能够以便捷初始化器的形式实现父类指定初始化器来作为满足规则2的一部分。

6、可失败初始化器
定义类、结构体或枚举初始化时可以失败在某些情况下会管大用。这个失败可能由以下几种方式触发，包括给初始化传入无效的形式参数值，
或缺少某种外部所需的资源，又或是其他阻止初始化的情况。

6.1、枚举的可失败初始化器
你可以使用一个可失败初始化器来在带一个或多个形式参数的枚举中选择合适的情况。如果提供的形式参数没有匹配合适的情况初始化器就可能失败。

6.2、带有原始值枚举的可失败初始化器
带有原始值的枚举会自动获得一个可失败初始化器 init?(rawValue:) ，
该可失败初始化器接收一个名为 rawValue 的合适的原始值类型形式参数如果找到了匹配的枚举情况就选择其一，或者没有找到匹配的值就触发初始化失败。

为了妥善处理这种可能失败的情况，在类、结构体或枚举中定义一个或多个可失败的初始化器。通过在 init 关键字后面添加问号( init? )来写。

6.3、初始化失败的传递
类，结构体或枚举的可失败初始化器可以横向委托到同一个类，结构体或枚举里的另一个可失败初始化器。
类似地，子类的可失败初始化器可以向上委托到父类的可失败初始化器。

无论哪种情况，如果你委托到另一个初始化器导致了初始化失败，那么整个初始化过程也会立即失败，并且之后任何初始化代码都不会执行。

6.4、重写可失败初始化器
你可以在子类里重写父类的可失败初始化器。就好比其他的初始化器。或者，你可以用子类的非可失败初始化器来重写父类可失败初始化器。
这样允许你定义一个初始化不会失败的子类，尽管父类的初始化允许失败。

注意如果你用非可失败的子类初始化器重写了一个可失败初始化器，向上委托到父类初始化器的唯一办法是强制展开父类可失败初始化器的结果。

6.5、可失败初始化器 init!
通常来讲我们通过在 init 关键字后添加问号 ( init? )的方式来定义一个可失败初始化器以创建一个合适类型的可选项实例。
另外，你也可以使用可失败初始化器创建一个隐式展开具有合适类型的可选项实例。通过在 init 后面添加惊叹号( init! )是不是问号。

你可以在 init? 初始化器中委托调用 init! 初始化器，反之亦然。 你也可以用 init! 重写 init? ，反之亦然。
你还可以用 init 委托调用 init! ，尽管当 init! 初始化器导致初始化失败时会触发断言。

7、必要初始化器
在类的初始化器前添加 required  修饰符来表明所有该类的子类都必须实现该初始化器：
